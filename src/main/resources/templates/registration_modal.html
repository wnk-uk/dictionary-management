<!DOCTYPE html>
<html lang="en">
<head th:replace="fragments.html :: head">
	<style>
		#registrationModal .table td {
			word-wrap: break-word;
			overflow-wrap: break-word;
			white-space: normal;
			max-width: 150px;
		}
		.editor-container {
			min-height: 200px;
		}
		.ql-editor {
			min-height: 150px;
		}
	</style>
</head>
<body id="page-top">
<div class="modal fade" id="registrationModal" tabindex="-1" role="dialog" aria-labelledby="registrationModalLabel" aria-hidden="true">
	<div class="modal-dialog modal-lg" role="document" style="max-width: 90vw;">
		<div class="modal-content">
			<div class="modal-header">
				<h5 class="modal-title" id="registrationModalLabel">New Multi Language Registration</h5>
				<button type="button" class="close" data-dismiss="modal" aria-label="Close">
					<span aria-hidden="true">Ã—</span>
				</button>
			</div>
			<div class="modal-body" style="overflow-x: auto">
				<form id="registrationForm" enctype="multipart/form-data">
					<div class="form-group">
						<label for="reqUsrNm">Requested By</label>
						<input type="text" class="form-control" id="reqUsrNm" th:value="${username}" readonly>
					</div>
					<table id="requestTables" class="table table-bordered">
						<thead>
						<tr>
							<th>As-Is<br/>(Existing Word)</th>
							<th>Language</th>
							<th>To-Be<br/>(New Word)</th>
							<th>New Translation</th>
							<th>Abbreviation</th>
						</tr>
						<tr>
							<th>Type</th>
							<th>Screen Path</th>
							<th>Source Path</th>
							<th>Comment</th>
							<th>Del</th>
						</tr>
						<tr>
							<th colspan="5">Editor & File Upload</th>
						</tr>
						</thead>
						<tbody id="requestTable">
						<tr>
							<td>
								<input type="text" class="form-control existingWord" placeholder="Search...">
								<div class="dropdown-menu existingWordsDropdown" style="top: initial !important; float: none !important; left: initial; height: 300px; overflow: auto;"></div>
							</td>
							<td>
								<select class="form-control langCode">
									<option value="ko_KR">Korean</option>
									<option value="en_US">English</option>
									<option value="ja_JP">Japanese</option>
									<option value="zh_CN">Chinese</option>
								</select>
							</td>
							<td><input type="text" class="form-control newWord"></td>
							<td><input type="text" class="form-control newTranslation"></td>
							<td><input type="text" class="form-control newAbbr"></td>
						</tr>
						<tr>
							<td>
								<select class="form-control wordType">
									<option value="Label">Label</option>
									<option value="Button">Button</option>
								</select>
							</td>
							<td><input type="text" class="form-control screenPath"></td>
							<td><input type="text" class="form-control sourcePath"></td>
							<td><input type="text" class="form-control comment"></td>
							<td style="vertical-align: middle;">
								<i class="fas fa-trash fa-lg text-black-900 removeRow"></i>
							</td>
						</tr>
						<tr>
							<td colspan="5">
								<div class="editor-container" id="editor-0"></div>
								<input type="file" class="form-control-file fileUpload" name="fileUpload" id="fileUpload-0" multiple>
								<button type="button" class="btn btn-secondary downloadFileBtn">Download Uploaded File</button>
							</td>
						</tr>
						</tbody>
					</table>
					<button type="button" class="btn btn-secondary" id="addRow">Add More</button>
				</form>
			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-primary" id="submitRequest">Submit Request</button>
			</div>
		</div>
	</div>
</div>

<script th:replace="fragments.html :: ajax-csrf-header"></script>
<script>
	function initQuillWhenReady() {
		console.log("initQuillWhenReady called");
		
		if (typeof Quill === 'undefined') {
			console.log("Quillì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ì¬ì‹œë„í•©ë‹ˆë‹¤.");
			setTimeout(initQuillWhenReady, 100);
			return;
		}
		
		console.log("Quill ë¡œë“œ ì™„ë£Œ, ì´ˆê¸°í™” ì‹œì‘...");
		
		let editorCount = 0;
		const editors = {};
		
		// ì²« ë²ˆì§¸ Quill ì—ë””í„° ì´ˆê¸°í™”
		const initialEditor = document.getElementById('editor-0');
		if (initialEditor) {
			editors[editorCount] = new Quill(initialEditor, {
				theme: 'snow',
				modules: {
					toolbar: [
						['bold', 'italic', 'underline'],
						['link', 'image'],
						[{ 'list': 'ordered' }, { 'list': 'bullet' }]
					]
				}
			});
			
			// ì´ë¯¸ì§€ ì‚½ì… ê°ì§€
			editors[editorCount].on('text-change', function(delta, oldDelta, source) {
				if (source === 'user') {
					const contents = editors[editorCount].root.innerHTML;
					const parser = new DOMParser();
					const doc = parser.parseFromString(contents, 'text/html');
					const images = doc.getElementsByTagName('img');
					if (images.length > 0) {
						for (let img of images) {
							const src = img.getAttribute('src');
							if (src && src.startsWith('data:image/')) {
								console.log("Image detected, storing in localStorage:", src);
								localStorage.setItem(`editorImage_${editorCount}`, src);
							}
						}
					}
				}
			});
		} else {
			console.error("ì´ˆê¸° ì»¨í…Œì´ë„ˆ #editor-0ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
		}
		
		// ê²€ìƒ‰ ê¸°ëŠ¥
		window.searchExistingWord = function(input) {
			const request = input.value.trim();
			if (request.length < 2) {
				closeDropdown(input);
				return;
			}
			$.ajax({
				url: "/api/multlang/search",
				type: "GET",
				data: { request: request },
				dataType: "json",
				success: function(data) {
					showDropdown(input, data);
				},
				error: function(xhr, status, error) {
					console.error("Error:", xhr.responseText);
				}
			});
		};
		
		function showDropdown(input, words) {
			let dropdown = input.parentElement.querySelector(".existingWordsDropdown");
			if (!dropdown) {
				dropdown = document.createElement("div");
				dropdown.classList.add("dropdown-menu", "show", "existingWordsDropdown");
				input.parentElement.appendChild(dropdown);
			}
			dropdown.innerHTML = "";
			if (words.length === 0) {
				dropdown.style.display = "none";
				return;
			}
			words.forEach(word => {
				let option = document.createElement("a");
				option.classList.add("dropdown-item");
				option.textContent = word;
				option.onclick = function() {
					input.value = word;
					dropdown.style.display = "none";
				};
				dropdown.appendChild(option);
			});
			dropdown.style.position = "fixed";
			dropdown.style.width = input.offsetWidth + "px";
			dropdown.style.zIndex = "1000";
			dropdown.style.display = "block";
		}
		
		function closeDropdown(input) {
			let dropdown = input.parentElement.querySelector(".existingWordsDropdown");
			if (dropdown) {
				dropdown.style.display = "none";
			}
		}
		
		// ê²€ìƒ‰ ì´ë²¤íŠ¸ ë°”ì¸ë”©
		document.querySelectorAll(".existingWord").forEach(input => {
			input.addEventListener("keyup", function() {
				searchExistingWord(this);
			});
		});
		
		// "Add More" ê¸°ëŠ¥
		document.getElementById("addRow").addEventListener("click", function() {
			console.log("Add Row button clicked");
			const tbodyTemplate = document.querySelector("#requestTable");
			const tbody = tbodyTemplate.cloneNode(false);
			
			const rows = Array.from(tbodyTemplate.children).map(row => {
				const newRow = row.cloneNode(false);
				Array.from(row.children).forEach(cell => {
					const newCell = cell.cloneNode(false);
					newCell.innerHTML = cell.innerHTML;
					newRow.appendChild(newCell);
				});
				return newRow;
			});
			rows.forEach(row => tbody.appendChild(row));
			
			tbody.querySelectorAll("input").forEach(input => input.value = "");
			editorCount++;
			const editorId = `editor-${editorCount}`;
			const editorContainer = tbody.querySelector(".editor-container");
			
			editorContainer.innerHTML = "";
			editorContainer.id = editorId;
			
			const fileInput = tbody.querySelector(".fileUpload");
			fileInput.id = `fileUpload-${editorCount}`;
			
			const downloadBtn = tbody.querySelector(".downloadFileBtn");
			if (downloadBtn) {
				downloadBtn.id = `downloadBtn-${editorCount}`;
				downloadBtn.addEventListener("click", function() {
					console.log("Download button clicked");
					const fileInput = tbody.querySelector(`#fileUpload-${editorCount}`);
					if (fileInput.files.length > 0) {
						const file = fileInput.files[0];
						const reader = new FileReader();
						reader.onload = function(e) {
							base64ToFile(e.target.result, file.name, file.type);
						};
						reader.readAsDataURL(file);
					}
					
					const editorInstance = editors[editorCount];
					if (editorInstance) {
						const contents = editorInstance.root.innerHTML;
						const parser = new DOMParser();
						const doc = parser.parseFromString(contents, 'text/html');
						const images = doc.getElementsByTagName('img');
						if (images.length > 0) {
							for (let img of images) {
								const src = img.getAttribute('src');
								if (src && src.startsWith('data:image/')) {
									const contentType = src.match(/data:(image\/[^;]+);/)[1];
									base64ToFile(src, `editor_image_${editorCount}.${contentType.split('/')[1]}`, contentType);
								}
							}
						}
					}
				});
			}
			
			const table = document.getElementById("requestTables");
			table.appendChild(tbody);
			
			setTimeout(() => {
				const newEditorContainer = document.getElementById(editorId);
				if (newEditorContainer) {
					console.log(`Initializing new editor #${editorId}`);
					if (editors[editorCount]) { editors[editorCount] = null; }
					editors[editorCount] = new Quill(newEditorContainer, {
						theme: 'snow',
						modules: {
							toolbar: [
								['bold', 'italic', 'underline'],
								['link', 'image'],
								[{ 'list': 'ordered' }, { 'list': 'bullet' }]
							]
						}
					});
					editors[editorCount].on('text-change', function(delta, oldDelta, source) {
						if (source === 'user') {
							const contents = editors[editorCount].root.innerHTML;
							const parser = new DOMParser();
							const doc = parser.parseFromString(contents, 'text/html');
							const images = doc.getElementsByTagName('img');
							if (images.length > 0) {
								for (let img of images) {
									const src = img.getAttribute('src');
									if (src && src.startsWith('data:image/')) {
										console.log("Image detected in new editor:", src);
										localStorage.setItem(`editorImage_${editorCount}`, src);
									}
								}
							}
						}
					});
				} else {
					console.error(`ìƒˆ ì»¨í…Œì´ë„ˆ #${editorId}ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
				}
			}, 10);
			
			tbody.querySelector(".existingWord")?.addEventListener("keyup", function() {
				searchExistingWord(this);
			});
			tbody.querySelector(".removeRow")?.addEventListener("click", function(e) {
				if (document.querySelectorAll("#requestTables tbody").length === 1) return;
				if (e.target.classList.contains("removeRow")) {
					const editorIdNum = tbody.querySelector(".editor-container").id.split('-')[1];
					delete editors[editorIdNum];
					e.target.closest("tbody").remove();
				}
			});
		});
		
		// "Submit Request" ê¸°ëŠ¥
		document.getElementById("submitRequest").addEventListener("click", function() {
			console.log("Submit button clicked");
			const formData = new FormData();
			formData.append("reqUsrNm", document.getElementById("reqUsrNm").value);
			let isValid = true;
			const details = [];
			
			document.querySelectorAll("#requestTables tbody").forEach((row, index) => {
				const newWord = row.querySelector(".newWord").value.trim();
				const newTranslation = row.querySelector(".newTranslation").value.trim();
				const wordField = row.querySelector(".newWord");
				const translationField = row.querySelector(".newTranslation");
				
				if (newWord === "") { isValid = false; wordField.classList.add("is-invalid"); } else { wordField.classList.remove("is-invalid"); }
				if (newTranslation === "") { isValid = false; translationField.classList.add("is-invalid"); } else { translationField.classList.remove("is-invalid"); }
				
				const editorContent = editors[index].root.innerHTML;
				const fileInput = row.querySelector(`.fileUpload`);
				
				const detail = {
					existingWord: row.querySelector(".existingWord").value,
					multlangCcd: row.querySelector(".langCode").value,
					multlangKey: newWord,
					multlangTranslCont: newTranslation,
					multlangTranslContAbbr: row.querySelector(".newAbbr").value,
					multlangTyp: row.querySelector(".wordType").value,
					screenPath: row.querySelector(".screenPath").value,
					sourcePath: row.querySelector(".sourcePath").value,
					comment: row.querySelector(".comment").value,
					editorContent: editorContent
				};
				details.push(detail);
				
				// 1. íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
				if (fileInput && fileInput.files.length > 0) {
					for (let i = 0; i < fileInput.files.length; i++) {
						console.log(`Adding file ${i} for index ${index}:`, fileInput.files[i]);
						formData.append("files", fileInput.files[i]); // "details[].files" â†’ "files"
					}
				} else {
					console.log(`No files found for index ${index}`);
				}
				
				// 2. Quill ì—ë””í„°ì˜ Base64 ì´ë¯¸ì§€ ì²˜ë¦¬
				const parser = new DOMParser();
				const doc = parser.parseFromString(editorContent, 'text/html');
				const images = doc.getElementsByTagName('img');
				if (images.length > 0) {
					for (let img of images) {
						const src = img.getAttribute('src');
						if (src && src.startsWith('data:image/')) {
							const contentType = src.match(/data:(image\/[^;]+);/)[1];
							const base64Data = src.split(',')[1];
							const byteCharacters = atob(base64Data);
							const byteNumbers = new Array(byteCharacters.length);
							for (let i = 0; i < byteCharacters.length; i++) {
								byteNumbers[i] = byteCharacters.charCodeAt(i);
							}
							const byteArray = new Uint8Array(byteNumbers);
							const blob = new Blob([byteArray], { type: contentType });
							console.log(`Adding editor image for index ${index}:`, `editor_image_${index}.${contentType.split('/')[1]}`);
							formData.append("files", blob, `editor_image_${index}.${contentType.split('/')[1]}`); // "details[].files" â†’ "files"
						}
					}
				} else {
					console.log(`No images found in editor for index ${index}`);
				}
			});
			
			if (!isValid) {
				alert("ğŸš¨ 'To-Be (New Word)'ì™€ 'New Translation' í•„ë“œëŠ” í•„ìˆ˜ ì…ë ¥ í•­ëª©ì…ë‹ˆë‹¤.");
				return;
			}
			
			formData.append("details", JSON.stringify(details));
			console.log("FormData contents before sending:");
			for (let [key, value] of formData.entries()) {
				console.log(key, value);
			}
			
			$.ajax({
				type: "POST",
				url: "/api/request/multlang",
				data: formData,
				processData: false,
				contentType: false,
				success: function(response) {
					alert("âœ… Request submitted successfully!");
					location.href = "/req/ALL/lists";
				},
				error: function(xhr, status, error) {
					console.error("AJAX Error:", xhr.responseText);
					if (typeof UT !== 'undefined' && UT.handleAjaxError) {
						UT.handleAjaxError(xhr, status, error);
					}
				}
			});
		});
		
		// ì´ˆê¸° íŒŒì¼ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ì´ë²¤íŠ¸ ì¶”ê°€
		document.querySelectorAll(".downloadFileBtn").forEach(btn => {
			btn.addEventListener("click", function() {
				console.log("Download button clicked");
				const fileInput = btn.closest("tr").querySelector(".fileUpload");
				if (fileInput && fileInput.files.length === 0) {
					alert("ë¨¼ì € íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!");
					return;
				}
				const file = fileInput.files[0];
				const reader = new FileReader();
				reader.onload = function(e) {
					base64ToFile(e.target.result, file.name, file.type);
				};
				reader.readAsDataURL(file);
			});
		});
	}
	
	function base64ToFile(base64, fileName, contentType) {
		const base64Data = base64.split(',')[1];
		const byteCharacters = atob(base64Data);
		const byteNumbers = new Array(byteCharacters.length);
		for (let i = 0; i < byteCharacters.length; i++) {
			byteNumbers[i] = byteCharacters.charCodeAt(i);
		}
		const byteArray = new Uint8Array(byteNumbers);
		const blob = new Blob([byteArray], { type: contentType });
		const url = URL.createObjectURL(blob);
		const link = document.createElement("a");
		link.href = url;
		link.download = fileName;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
		URL.revokeObjectURL(url);
	}
	
	// DOM ë¡œë“œ í›„ ì´ˆê¸°í™”
	document.addEventListener("DOMContentLoaded", function() {
		console.log("DOM ë¡œë“œ ì™„ë£Œ, ì´ˆê¸°í™” ì‹œì‘...");
		initQuillWhenReady();
	});
</script>
</body>
</html>